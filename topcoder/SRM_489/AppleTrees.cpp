#include <vector>
#include <map>
#include <set>
#include <queue>
#include <algorithm>
#include <sstream>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

using namespace std;

#define foreach(it, c) for(typeof(c.begin()) it = c.begin(); it != c.end(); it++)

typedef long long int lli;
typedef pair<int,int> ii;

// DP[i][j][d] = number of ways to pack i trees 
// with j tree placeholders, using exactly d spaces
const lli MOD = 1000000007;
const int MAXD = 100100, MAXM = 4000;
int DP[41][41][MAXM];

lli fact[MAXD], invfact[MAXD];

void add(int &x, lli val){
    lli t = x + val;
    t %= MOD;
    x = t;
}

void mul(int &x, lli val){
    lli t = x * val;
    t %= MOD;
    x = t;
}

int gcd(int a, int b){
    if(a == 0 or b == 0){
        return max(a,b);
    }
    return gcd(b,a%b);
}

lli b[40];
lli modexp(lli a, lli x){
    lli ans = 1;
    b[0] = a % MOD;
    for (int i = 1; i < 40; i++){
        b[i] = (b[i-1]*b[i-1]) % MOD;
    }
    for (int i = 0; i < 40; i++){
        if(x & ((lli(1)<<i))){
            ans *= b[i];
            ans %= MOD;
        }
    }
    return ans;
}


class AppleTrees {
public:
    int theCount(int D, vector <int> r) {
        sort(r.rbegin(),r.rend());
        int n = r.size();

        memset(DP,0,sizeof(DP));
        DP[0][1][1] = 1;

        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= n; j++){
                for (int d = 0; d < MAXM; d++){
                    if(DP[i-1][j][d] == 0)
                        continue;
                    // just use up one placeholder
                    add(DP[i][j-1][d],lli(j)*DP[i-1][j][d]);

                    // use a placeholder and create 
                    // 1) left or 2) right segment with a placeholder
                    add(DP[i][j][d + r[i-1]],lli(2*j)*DP[i-1][j][d]);

                    // use a placeholder and create two placeholders, left and right
                    if(j < n){
                        add(DP[i][j+1][d + 2*r[i-1]], lli(j)*DP[i-1][j][d]);
                    }
                }
            }
        }

        fact[0] = 1;
        for (int i = 1; i < MAXD; i++){
            fact[i] = (i*fact[i-1]) % MOD;
        }
    
        for (int i = 0; i < MAXD; i++){
            invfact[i] = modexp(fact[i],MOD-2);
        }

        // ans = sum over m, DP[n][0][m] * (number of ways to 
        //                                distribute D-m balls in n+1 bins)
        // =  DP[n][0][m] * (D-m+n) choose (n)
        lli ans = 0;
        for (int m = 0; m < min(D+1,MAXM); m++){
            lli summand = lli(DP[n][0][m]) * fact[D-m+n];
            summand %= MOD;
            summand *= invfact[n]; summand %= MOD;
            summand *= invfact[D-m]; summand %= MOD;
            ans += summand;
            ans %= MOD;
        }
        
        return ans;

    }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	AppleTrees *obj;
	int answer;
	obj = new AppleTrees();
	clock_t startTime = clock();
	answer = obj->theCount(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	vector <int> p1;
	int p2;
	
	{
	// ----- test 0 -----
	p0 = 10;
	int t1[] = {40};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 10;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 4;
	int t1[] = {1,1,1,1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 24;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 4;
	int t1[] = {1,1,2};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 4;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 58;
	int t1[] = {5,8};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2550;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 47;
	int t1[] = {4,8,9};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 28830;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	p0 = 100000;
	int t1[] = {21,37,23,13,32,22,9,39};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 923016564;
	all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
